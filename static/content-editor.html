<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Content Editor - Tama</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/style.css">
    <link rel="stylesheet" href="/content-editor.css">
</head>

<body>
    <div class="editor-container">
        <h1>Content Editor</h1>

        <div class="section">
            <div class="section-header" onclick="toggleSection('fileSection')">
                <span class="section-toggle">▼</span>
                <h2>File</h2>
            </div>
            <div id="fileSection" class="section-content">
                <div class="button-row">
                    <label for="loadFile" class="button file-button">Upload</label>
                    <input type="file" id="loadFile" accept=".txt" style="display: none;">
                    <button id="downloadButton" style="padding: 15px 30px; font-size: 16px;">Download</button>
                    <button id="publishButton" style="padding: 15px 30px; font-size: 16px;">Publish</button>
                </div>
                <div id="publishError"></div>
            </div>
        </div>

        <div class="section">
            <div class="section-header" onclick="toggleSection('midiSection')">
                <span class="section-toggle">▼</span>
                <h2>MIDI</h2>
            </div>
            <div id="midiSection" class="section-content">
                <div class="form-group">
                    <label for="midiComposition">MIDI Composition</label>
                    <textarea id="midiComposition" placeholder="Enter MIDI notes (e.g., 4c 4e 4g 2c5)">4c 4e 4g 2c5 4g 4e 2c</textarea>
                </div>
                <div class="button-row">
                    <button id="playButton">Play</button>
                    <button id="stopButton">Stop</button>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-header" onclick="toggleSection('pixelSection')">
                <span class="section-toggle">▼</span>
                <h2>Pixel Art</h2>
            </div>
            <div id="pixelSection" class="section-content">
                <div class="form-group-inline">
                    <label for="canvasWidth">Canvas Size (pixels):</label>
                    <input type="number" id="canvasWidth" value="64" min="2" max="64" step="2">
                    <span>×</span>
                    <input type="number" id="canvasHeight" value="40" min="4" max="40" step="4">
                    <button id="resizeButton">Resize</button>
                </div>

                <div class="form-group-inline">
                    <label for="fps">Animation FPS (1 - 30):</label>
                    <input type="number" id="fps" step="1" min="1" max="30" value="10">
                </div>

                <div class="canvas-tools-container">
                    <div class="canvas-container">
                        <canvas id="pixelCanvas"></canvas>
                    </div>
                    <div class="tools-panel">
                        <button id="clearButton">Clear Frame</button>
                        <button id="fillButton">Fill Frame</button>
                        <button id="togglePreviewButton">Show Preview</button>
                    </div>
                </div>

                <div class="frames-container">
                    <div class="frames-header">
                        <h3>Frames (<span id="frameCount">0</span>) - <span id="currentFrameLabel">No frames</span></h3>
                    </div>
                    <div id="framesList" class="frames-list"></div>
                    <div class="button-row">
                        <button id="duplicateFrameButton">Duplicate Frame</button>
                        <button id="deleteFrameButton">Delete Frame</button>
                        <button id="addFrameButton">+ Add Empty Frame</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="previewPanel" class="preview-panel">
        <div class="preview-header">
            <h3>Animation Preview</h3>
            <button id="closePreviewButton" class="close">×</button>
        </div>
        <div class="preview-controls">
            <span id="previewFrameLabel">Frame 1 / 1</span>
        </div>
        <div class="preview-canvas-container">
            <canvas id="previewCanvas"></canvas>
        </div>
    </div>

    <script src="/auth.js"></script>
    <script src="/network.js"></script>
    <script src="/midi.js" type="module"></script>
    <script type="module">
        import { midiPlayer } from '/midi.js';

        function toggleSection(sectionId) {
            const content = document.getElementById(sectionId);
            const header = content.previousElementSibling;
            const toggle = header.querySelector('.section-toggle');

            content.classList.toggle('collapsed');
            toggle.classList.toggle('collapsed');
        }

        window.toggleSection = toggleSection;

        const TV_WIDTH = 32;
        const TV_HEIGHT = 10;
        const CELL_SIZE = 10;
        let canvasWidth = TV_WIDTH;  // in braille characters
        let canvasHeight = TV_HEIGHT; // in braille characters
        let PIXEL_WIDTH = canvasWidth * 2;
        let PIXEL_HEIGHT = canvasHeight * 4;

        let frames = [];
        let currentFrameIndex = -1;
        let previewAnimationInterval = null;
        let previewFrameIndex = 0;
        const previewZoom = 1;

        const canvas = document.getElementById('pixelCanvas');
        const ctx = canvas.getContext('2d');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');

        let isDrawing = false;
        let drawMode = true;

        function getPixelColor() {
            return window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches
                ? '#081820'
                : '#88c070';
        }

        function updateCanvasSize() {
            PIXEL_WIDTH = canvasWidth * 2;
            PIXEL_HEIGHT = canvasHeight * 4;
            canvas.width = PIXEL_WIDTH * CELL_SIZE;
            canvas.height = PIXEL_HEIGHT * CELL_SIZE;
            updatePreviewCanvasSize();
        }

        function updatePreviewCanvasSize() {
            // Size will be calculated in renderPreview based on braille text dimensions
        }

        function resizeFrames(newWidth, newHeight) {
            const newPixelWidth = newWidth * 2;
            const newPixelHeight = newHeight * 4;

            const resizedFrames = frames.map(frame => {
                const newFrame = Array(newPixelHeight).fill(null).map(() => Array(newPixelWidth).fill(false));

                const offsetX = Math.floor((newPixelWidth - PIXEL_WIDTH) / 2);
                const offsetY = Math.floor((newPixelHeight - PIXEL_HEIGHT) / 2);

                for (let y = 0; y < Math.min(PIXEL_HEIGHT, newPixelHeight); y++) {
                    for (let x = 0; x < Math.min(PIXEL_WIDTH, newPixelWidth); x++) {
                        const targetY = y + offsetY;
                        const targetX = x + offsetX;
                        if (targetY >= 0 && targetY < newPixelHeight && targetX >= 0 && targetX < newPixelWidth) {
                            newFrame[targetY][targetX] = frame[y][x];
                        }
                    }
                }

                return newFrame;
            });

            frames = resizedFrames;
            canvasWidth = newWidth;
            canvasHeight = newHeight;
            updateCanvasSize();
            render();
        }

        function getCurrentFrame() {
            if (currentFrameIndex >= 0 && currentFrameIndex < frames.length) {
                return frames[currentFrameIndex];
            }
            return null;
        }

        function addFrame() {
            const newFrame = Array(PIXEL_HEIGHT).fill(null).map(() => Array(PIXEL_WIDTH).fill(false));
            frames.push(newFrame);
            currentFrameIndex = frames.length - 1;
            updateFramesList();
            render();
        }

        function deleteFrame(index) {
            if (frames.length === 0) return;
            frames.splice(index, 1);
            if (currentFrameIndex >= frames.length) {
                currentFrameIndex = frames.length - 1;
            }
            updateFramesList();
            render();
        }

        function duplicateFrame() {
            if (currentFrameIndex < 0 || currentFrameIndex >= frames.length) {
                addFrame();
                return;
            }
            const copy = frames[currentFrameIndex].map(row => [...row]);
            frames.splice(currentFrameIndex + 1, 0, copy);
            currentFrameIndex++;
            updateFramesList();
            render();
        }

        function selectFrame(index) {
            currentFrameIndex = index;
            updateFramesList();
            render();
        }

        function updateFramesList() {
            const framesList = document.getElementById('framesList');
            framesList.innerHTML = '';

            frames.forEach((frame, index) => {
                const frameButton = document.createElement('button');
                frameButton.className = 'frame-button';
                if (index === currentFrameIndex) {
                    frameButton.classList.add('active');
                }
                frameButton.textContent = `${index + 1}`;
                frameButton.draggable = true;

                frameButton.addEventListener('click', () => selectFrame(index));

                frameButton.addEventListener('dragstart', (e) => {
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', index.toString());
                });

                frameButton.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                });

                frameButton.addEventListener('dragenter', (e) => {
                    e.preventDefault();
                    frameButton.classList.add('drag-over');
                });

                frameButton.addEventListener('dragleave', () => {
                    frameButton.classList.remove('drag-over');
                });

                frameButton.addEventListener('drop', (e) => {
                    e.preventDefault();
                    frameButton.classList.remove('drag-over');

                    const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    const toIndex = index;

                    if (fromIndex !== toIndex) {
                        const [movedFrame] = frames.splice(fromIndex, 1);
                        frames.splice(toIndex, 0, movedFrame);

                        if (currentFrameIndex === fromIndex) {
                            currentFrameIndex = toIndex;
                        } else if (fromIndex < currentFrameIndex && toIndex >= currentFrameIndex) {
                            currentFrameIndex--;
                        } else if (fromIndex > currentFrameIndex && toIndex <= currentFrameIndex) {
                            currentFrameIndex++;
                        }

                        updateFramesList();
                    }
                });

                framesList.appendChild(frameButton);
            });

            document.getElementById('frameCount').textContent = frames.length;
            if (frames.length > 0 && currentFrameIndex >= 0) {
                document.getElementById('currentFrameLabel').textContent = `Frame ${currentFrameIndex + 1} / ${frames.length}`;
            } else {
                document.getElementById('currentFrameLabel').textContent = 'No frames';
            }
        }

        function render() {
            ctx.fillStyle = getBgColor();
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const frame = getCurrentFrame();
            if (frame) {
                ctx.fillStyle = getPixelColor();
                for (let y = 0; y < PIXEL_HEIGHT; y++) {
                    for (let x = 0; x < PIXEL_WIDTH; x++) {
                        if (frame[y][x]) {
                            ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        }
                    }
                }
            }

            ctx.strokeStyle = getPixelColor();
            ctx.globalAlpha = 0.2;
            for (let x = 0; x <= PIXEL_WIDTH; x++) {
                ctx.beginPath();
                ctx.moveTo(x * CELL_SIZE, 0);
                ctx.lineTo(x * CELL_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= PIXEL_HEIGHT; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * CELL_SIZE);
                ctx.lineTo(canvas.width, y * CELL_SIZE);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
        }

        function renderPreview(frameIndex) {
            if (frames.length === 0 || frameIndex < 0 || frameIndex >= frames.length) {
                return;
            }

            const frame = frames[frameIndex];
            const brailleText = pixelsToBraille(frame);

            // Render braille text to canvas
            const lines = brailleText.split('\n');
            const maxLineLength = Math.max(...lines.map(line => line.length));

            const charWidth = 9 * previewZoom;
            const charHeight = 18 * previewZoom;
            const characterSpacing = (charWidth / 6.0);
            const lineSpacing = characterSpacing * 2;

            previewCanvas.width = maxLineLength * (charWidth + characterSpacing);
            previewCanvas.height = lines.length * (charHeight + lineSpacing);

            // Clear background
            previewCtx.fillStyle = getBgColor();
            previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);

            // Set font and draw text
            previewCtx.font = `${charHeight}px 'Fira Code', monospace`;
            previewCtx.textBaseline = 'top';
            previewCtx.fillStyle = getPixelColor();

            for (let y = 0; y < lines.length; y++) {
                const line = lines[y];
                for (let x = 0; x < line.length; x++) {
                    const char = line[x] || ' ';
                    previewCtx.fillText(char, x * (charWidth + characterSpacing), y * (charHeight + lineSpacing));
                }
            }

            if (frames.length > 0) {
                document.getElementById('previewFrameLabel').textContent = `Frame ${frameIndex + 1} / ${frames.length}`;
            }
        }

        function getPixelCoords(event) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((event.clientX - rect.left) / CELL_SIZE);
            const y = Math.floor((event.clientY - rect.top) / CELL_SIZE);
            return { x, y };
        }

        function getBgColor() {
            return window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches
                ? '#f0faf0'
                : '#081820';
        }

        function setPixel(x, y, value) {
            const frame = getCurrentFrame();
            if (frame && x >= 0 && x < PIXEL_WIDTH && y >= 0 && y < PIXEL_HEIGHT) {
                frame[y][x] = value;
                render();
            }
        }

        canvas.addEventListener('mousedown', (e) => {
            const frame = getCurrentFrame();
            if (!frame) return;

            isDrawing = true;
            const { x, y } = getPixelCoords(e);
            drawMode = !frame[y][x];
            setPixel(x, y, drawMode);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                const { x, y } = getPixelCoords(e);
                setPixel(x, y, drawMode);
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
        });

        document.getElementById('addFrameButton').addEventListener('click', addFrame);

        document.getElementById('deleteFrameButton').addEventListener('click', () => {
            if (currentFrameIndex >= 0) {
                deleteFrame(currentFrameIndex);
            }
        });

        document.getElementById('duplicateFrameButton').addEventListener('click', duplicateFrame);

        document.getElementById('clearButton').addEventListener('click', () => {
            const frame = getCurrentFrame();
            if (frame) {
                for (let y = 0; y < PIXEL_HEIGHT; y++) {
                    for (let x = 0; x < PIXEL_WIDTH; x++) {
                        frame[y][x] = false;
                    }
                }
                render();
            }
        });

        document.getElementById('fillButton').addEventListener('click', () => {
            const frame = getCurrentFrame();
            if (frame) {
                for (let y = 0; y < PIXEL_HEIGHT; y++) {
                    for (let x = 0; x < PIXEL_WIDTH; x++) {
                        frame[y][x] = true;
                    }
                }
                render();
            }
        });

        document.getElementById('resizeButton').addEventListener('click', () => {
            const newPixelWidth = parseInt(document.getElementById('canvasWidth').value);
            const newPixelHeight = parseInt(document.getElementById('canvasHeight').value);

            // Convert pixels to characters (2 pixels wide, 4 pixels tall per character)
            const newWidth = newPixelWidth / 2;
            const newHeight = newPixelHeight / 4;

            if (newPixelWidth < 2 || newPixelWidth > 64 || newPixelHeight < 4 || newPixelHeight > 40 ||
                newPixelWidth % 2 !== 0 || newPixelHeight % 4 !== 0) {
                alert('Canvas dimensions must be 2-64 pixels wide (multiples of 2) and 4-40 pixels tall (multiples of 4)');
                return;
            }

            resizeFrames(newWidth, newHeight);
        });

        document.getElementById('togglePreviewButton').addEventListener('click', () => {
            const panel = document.getElementById('previewPanel');
            const button = document.getElementById('togglePreviewButton');

            if (panel.classList.contains('visible')) {
                panel.classList.remove('visible');
                button.textContent = 'Show Preview';
                stopPreviewAnimation();
            } else {
                panel.classList.add('visible');
                button.textContent = 'Hide Preview';
                if (frames.length > 0) {
                    previewFrameIndex = 0;
                    renderPreview(previewFrameIndex);
                    playPreviewAnimation();
                }
            }
        });

        document.getElementById('closePreviewButton').addEventListener('click', () => {
            document.getElementById('previewPanel').classList.remove('visible');
            document.getElementById('togglePreviewButton').textContent = 'Show Preview';
            stopPreviewAnimation();
        });

        function playPreviewAnimation() {
            if (frames.length === 0) return;
            if (previewAnimationInterval) return;

            const fps = parseFloat(document.getElementById('fps').value) || 10;
            const interval = 1000 / fps;

            previewAnimationInterval = setInterval(() => {
                previewFrameIndex = (previewFrameIndex + 1) % frames.length;
                renderPreview(previewFrameIndex);
            }, interval);
        }

        function stopPreviewAnimation() {
            if (previewAnimationInterval) {
                clearInterval(previewAnimationInterval);
                previewAnimationInterval = null;
            }
        }


        let isDraggingPreview = false;
        let previewDragOffsetX = 0;
        let previewDragOffsetY = 0;

        document.querySelector('.preview-header').addEventListener('mousedown', (e) => {
            isDraggingPreview = true;
            const panel = document.getElementById('previewPanel');
            const rect = panel.getBoundingClientRect();
            previewDragOffsetX = e.clientX - rect.left;
            previewDragOffsetY = e.clientY - rect.top;
        });

        document.addEventListener('mousemove', (e) => {
            if (isDraggingPreview) {
                const panel = document.getElementById('previewPanel');
                panel.style.left = (e.clientX - previewDragOffsetX) + 'px';
                panel.style.top = (e.clientY - previewDragOffsetY) + 'px';
                panel.style.right = 'auto';
            }
        });

        document.addEventListener('mouseup', () => {
            isDraggingPreview = false;
        });

        function pixelsToBraille(pixels) {
            const BRAILLE_BASE = 0x2800;
            const lines = [];
            const charHeight = Math.ceil(pixels.length / 4);
            const charWidth = Math.ceil(pixels[0].length / 2);

            for (let charY = 0; charY < charHeight; charY++) {
                let line = '';
                for (let charX = 0; charX < charWidth; charX++) {
                    const baseX = charX * 2;
                    const baseY = charY * 4;

                    let brailleValue = 0;

                    const brailleOffsets = [
                        [0, 0, 0x01], [0, 1, 0x02], [0, 2, 0x04], [0, 3, 0x40],
                        [1, 0, 0x08], [1, 1, 0x10], [1, 2, 0x20], [1, 3, 0x80]
                    ];

                    for (const [dx, dy, bit] of brailleOffsets) {
                        const x = baseX + dx;
                        const y = baseY + dy;
                        if (y < pixels.length && x < pixels[0].length && pixels[y][x]) {
                            brailleValue |= bit;
                        }
                    }

                    const char = String.fromCharCode(BRAILLE_BASE + brailleValue);
                    line += char;
                }
                lines.push(line.trimEnd());
            }

            return lines.join('\n');
        }

        function brailleToPixels(brailleText, charWidth, charHeight) {
            const lines = brailleText.trim().split('\n');
            const framesData = [];

            for (let frameStart = 0; frameStart < lines.length; frameStart += charHeight) {
                const frameLines = lines.slice(frameStart, frameStart + charHeight);
                const pixelHeight = charHeight * 4;
                const pixelWidth = charWidth * 2;
                const pixels = Array(pixelHeight).fill(null).map(() => Array(pixelWidth).fill(false));

                for (let charY = 0; charY < frameLines.length; charY++) {
                    const line = frameLines[charY];
                    for (let charX = 0; charX < Math.min(line.length, charWidth); charX++) {
                        const char = line[charX];
                        const brailleValue = char.charCodeAt(0) - 0x2800;

                        const baseX = charX * 2;
                        const baseY = charY * 4;

                        const brailleOffsets = [
                            [0, 0, 0x01], [0, 1, 0x02], [0, 2, 0x04], [0, 3, 0x40],
                            [1, 0, 0x08], [1, 1, 0x10], [1, 2, 0x20], [1, 3, 0x80]
                        ];

                        for (const [dx, dy, bit] of brailleOffsets) {
                            if (brailleValue & bit) {
                                const x = baseX + dx;
                                const y = baseY + dy;
                                if (x < pixelWidth && y < pixelHeight) {
                                    pixels[y][x] = true;
                                }
                            }
                        }
                    }
                }

                framesData.push(pixels);
            }

            return framesData;
        }

        function parseContentFile(fileContent) {
            const lines = fileContent.split('\n');
            let midi = '';
            let art = '';
            let width = 20;
            let height = 10;
            let fps = 10;
            let inMidi = false;
            let inArt = false;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];

                if (line.includes('--- MIDI ---')) {
                    inMidi = true;
                    inArt = false;
                    continue;
                }

                if (line.includes('--- ART ---')) {
                    inMidi = false;
                    inArt = true;
                    continue;
                }

                if (inMidi && line.trim()) {
                    const midiContent = line.replace(/^--bpm\s+\d+\s*/, '').trim();
                    if (midiContent) {
                        midi = midiContent;
                    }
                }

                if (inArt) {
                    const match = line.match(/Ascii Art Animation,\s*(\d+)x(\d+),\s*(\d+(?:\.\d+)?)fps/);
                    if (match) {
                        width = parseInt(match[1]);
                        height = parseInt(match[2]);
                        fps = parseFloat(match[3]);
                    } else if (line.trim()) {
                        art += line + '\n';
                    }
                }
            }

            return { midi, art, width, height, fps };
        }

        document.getElementById('loadFile').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const content = event.target.result;
                const parsed = parseContentFile(content);

                document.getElementById('midiComposition').value = parsed.midi;
                document.getElementById('fps').value = parsed.fps;
                // Convert characters to pixels for display
                document.getElementById('canvasWidth').value = parsed.width * 2;
                document.getElementById('canvasHeight').value = parsed.height * 4;

                canvasWidth = parsed.width;
                canvasHeight = parsed.height;
                updateCanvasSize();

                if (parsed.art.trim()) {
                    frames = brailleToPixels(parsed.art, parsed.width, parsed.height);
                    if (frames.length > 0) {
                        currentFrameIndex = 0;
                    }
                } else {
                    frames = [];
                    currentFrameIndex = -1;
                }

                updateFramesList();
                render();
            };
            reader.readAsText(file);
        });

        document.getElementById('downloadButton').addEventListener('click', () => {
            const fps = parseFloat(document.getElementById('fps').value);
            const midiComposition = document.getElementById('midiComposition').value.trim();

            let content = '--- MIDI ---\n';
            if (midiComposition) {
                content += `--bpm 150 ${midiComposition}\n`;
            } else {
                content += '--bpm 150\n';
            }
            content += '--- ART ---\n';
            content += `Ascii Art Animation, ${canvasWidth}x${canvasHeight}, ${fps}fps\n`;

            frames.forEach(frame => {
                const brailleArt = pixelsToBraille(frame);
                content += brailleArt + '\n';
            });

            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'content.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        midiPlayer.initAudioContext();

        document.getElementById('playButton').addEventListener('click', async () => {
            const composition = document.getElementById('midiComposition').value.trim();

            if (!composition) {
                alert('Please enter a MIDI composition');
                return;
            }

            try {
                await midiPlayer.play(composition);
            } catch (error) {
                alert(`Failed to play composition: ${error.message}`);
                console.error('Play error:', error);
            }
        });

        document.getElementById('stopButton').addEventListener('click', () => {
            midiPlayer.stop();
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                midiPlayer.stop();
            }
        });

        document.getElementById('publishButton').addEventListener('click', async () => {
            const publishError = document.getElementById('publishError');
            publishError.textContent = '';

            const auth = window.authManager;
            if (!auth.isAuthenticated()) {
                publishError.textContent = 'Please login first';
                window.location.href = '/';
                return;
            }

            const channel = auth.getChannel();
            if (!channel || !channel.id) {
                publishError.textContent = 'Invalid authentication. Please login again.';
                return;
            }

            const fps = parseFloat(document.getElementById('fps').value);

            if (isNaN(fps) || fps < 1 || fps > 30) {
                publishError.textContent = 'FPS must be between 1 and 30';
                return;
            }

            let brailleArt = `Ascii Art Animation, ${canvasWidth}x${canvasHeight}, ${fps}fps\n`;
            frames.forEach(frame => {
                brailleArt += pixelsToBraille(frame) + '\n';
            });

            const midiComposition = document.getElementById('midiComposition').value.trim();

            try {
                const payload = {
                    channel_id: channel.id,
                    name: '',
                    art: brailleArt.trim(),
                    midi: midiComposition,
                    fps: fps
                };

                const response = await httpPost('/content', payload, auth.getToken());
                const result = await handleResponse(response);

                if (result && result.id) {
                    window.location.href = `/view/content/${result.id}`;
                } else {
                    publishError.textContent = 'Content published successfully!';
                    setTimeout(() => {
                        window.location.href = '/';
                    }, 1000);
                }
            } catch (error) {
                publishError.textContent = `Failed to publish: ${error.message}`;
                console.error('Publish error:', error);
            }
        });

        window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', () => {
            render();
            if (frames.length > 0) {
                renderPreview(previewFrameIndex);
            }
        });

        updateCanvasSize();
        addFrame();
        render();
    </script>
</body>

</html>
